# Задача №1. Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых
# трех уроков. Проанализировать результат и определить программы с наиболее эффективным использованием памяти.
# Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько вариантов кода для одной и той же задачи.
# Результаты анализа вставьте в виде комментариев к коду. Также укажите в комментариях версию Python и разрядность
# вашей ОС.

# Windows 10 тип системы 64-разрядная операционная система, процессор x64. Версия Python 3.10

# Домашнее задание №3. Задача №5. В массиве найти максимальный отрицательный элемент. Вывести на экран его значение и
# позицию в массиве.
import sys
from random import random

n = 15
list_num = []
for i in range(n):
    list_num.append(int(random() * 100) - 50)
print(list_num)

i = 0
idx = -1
while i < n:
    if list_num[i] < 0 and idx == -1:
        idx = i
    elif 0 > list_num[i] > list_num[idx]:
        idx = i
    i += 1

print(f'Саммое отрицательное число: {list_num[idx]} под индексом {idx + 1}')
print(f'Размер объекта n равен: {sys.getsizeof(n)}')
print(f'Размер объекта list_num равен: {sys.getsizeof(list_num)}')
print(f'Размер объекта i равен: {sys.getsizeof(i)}')
print(f'Размер объекта idx равен: {sys.getsizeof(idx)}')

# Общий размер занимаемой памяти 268 байт, сложность алгоритма по скорости и по занимаемой памяти O(n). Можно
# сократить количество выделяемой памяти на 84 байта если почистить или переопределить переменные n, i и idx.

# **********************************************************************************************************************

# Домашнее задание №3. Задача №9. Найти максимальный элемент среди минимальных элементов столбцов матрицы.

m_1 = 10
m_2 = 5
matrix = []
for i in range(m_2):
    matrix_x = []
    for j in range(m_1):
        matrix_z = int(random() * 200)
        matrix_x.append(matrix_z)
        print(matrix_z, end=' ')
    matrix.append(matrix_x)
    print()

matrix_q = -1
for j in range(m_1):
    matrix_w = 200
    for i in range(m_2):
        if matrix[i][j] < matrix_w:
            matrix_w = matrix[i][j]
    if matrix_w > matrix_q:
        matrix_q = matrix_w
print("Максимальный эелемент равен: ", matrix_q)
print(f'Размер объекта m_1 равен: {sys.getsizeof(m_1)}')
print(f'Размер объекта m_2 равен: {sys.getsizeof(m_2)}')
print(f'Размер объекта matrix равен: {sys.getsizeof(matrix)}')
print(f'Размер объекта matrix_x равен: {sys.getsizeof(matrix_x)}')
print(f'Размер объекта matrix_q равен: {sys.getsizeof(matrix_q)}')
print(f'Размер объекта matrix_z равен: {sys.getsizeof(matrix_z)}')
print(f'Размер объекта matrix_w равен: {sys.getsizeof(matrix_w)}')

# Общий размер занимаемой памяти 444 байт, сложность алгоритма по скорости 0(n**2) и по занимаемой памяти O(n). Можно
# сократить количество выделяемой памяти на 140 байт если почистить или переопределить все переменные кроме matrix и
# matrix_x.

# **********************************************************************************************************************

# Домашнее задание №3. Задача №1. В диапазоне натуральных чисел от 2 до 99 определить, сколько из них кратны каждому
# из чисел в диапазоне от 2 до 9.

num = []
num_2 = [2, 3, 4, 5, 6, 7, 8, 9]
for i in range(2, 100):
    num.append(i)


def multiple(num_x, num_y):
    result = 0
    for idx in num_y:
        for z in num_x:
            if z % idx == 0:
                result += 1
        print(f' Для числа {idx} количество кратных {result}')
        result = 0


multiple(num, num_2)

print(f'Размер объекта num равен: {sys.getsizeof(num)}')
print(f'Размер объекта num_2 равен: {sys.getsizeof(num_2)}')
print(f'Размер объекта multiple равен: {sys.getsizeof(multiple)}')

# Общий размер занимаемой памяти 1 184 байт, сложность алгоритма по скорости 0(n**2) и по занимаемой памяти O(n).
# Cократить количество выделяемой памяти чисткой переменных или переопределением нельзя так как нет временных
# переменных. Если попробовать решить данный алгаритм, с применением дополнительного списка, без применения
# вложенного цикла, можно сократить скорость его исполнения до O(n), но увеличится объём занимаемой памяти,
# следовательно этот алгаритм уже оптимизирован по занимаемому размеру памяти в убыток скорости.
